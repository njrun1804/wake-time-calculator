<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wake Time Calculator</title>
    <!-- Performance: warm up CDNs used for UI frameworks -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin />
    <link rel="dns-prefetch" href="//cdn.tailwindcss.com" />
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net" />
    <!-- Tailwind runtime CDN and DaisyUI (CSS link is later in head) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #f5f6f8;
        color: #1f2933;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1.25rem;
      }
      /* Hero background + glass effect */
      :root {
        /* Optional image path, e.g., url('img/boston.jpg'); leave none for gradients */
        --hero-img: none;
      }
      .hero-bg {
        position: fixed;
        inset: 0;
        z-index: -1;
        background:
          linear-gradient(180deg, rgba(21, 64, 159, 0.65), rgba(255, 208, 0, 0.35)),
          var(--hero-img) center/cover no-repeat,
          conic-gradient(from 200deg at 50% 0%, #15409f, #0b2a7a, #15409f);
        filter: saturate(1.05);
      }
      @media (prefers-color-scheme: dark) {
        .hero-bg {
          filter: brightness(0.85) saturate(1.1);
        }
      }
      .glass-main {
        background: rgba(255, 255, 255, 0.65);
        border: 1px solid rgba(255, 255, 255, 0.4);
        -webkit-backdrop-filter: blur(8px) saturate(1.05);
        backdrop-filter: blur(8px) saturate(1.05);
      }
      main {
        width: min(100%, 720px);
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.06);
        padding: clamp(1.25rem, 1.5vw + 0.75rem, 2rem);
        display: grid;
        gap: 1.25rem;
      }
      h1 {
        margin: 0;
        font-size: clamp(1.5rem, 2vw + 0.75rem, 1.9rem);
        text-align: center;
        letter-spacing: -0.02em;
        line-height: 1.1;
      }
      .hidden {
        display: none !important;
      }
      .mt-neg-half {
        margin-top: -0.5rem;
      }
      form {
        display: grid;
        gap: 0.75rem;
        margin-bottom: 0;
      }
      .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.75rem;
      }
      @media (max-width: 520px) {
        .form-row {
          grid-template-columns: 1fr;
        }
      }
      .field-group {
        display: grid;
        gap: 0.35rem;
      }
      label {
        font-weight: 600;
        font-size: 0.9rem;
      }
      input[type='time'],
      input[type='number'],
      select {
        width: 100%;
        font: inherit;
        padding: 0.5rem 0.65rem;
        border: 1px solid #d2d8e1;
        border-radius: 8px;
        background: #fdfdff;
        font-size: 0.95rem;
      }
      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
      }
      /* Button styles are handled by DaisyUI .btn classes now */
      .status {
        min-height: 1.25rem;
        font-size: 0.95rem;
        color: #2563eb;
        font-weight: 600;
      }
      .output {
        border-radius: 12px;
        background: linear-gradient(145deg, #f8fbff, #eef2f8);
        padding: 0.75rem 1rem;
        margin-top: -0.5rem;
      }
      .wake-display {
        display: flex;
        align-items: baseline;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .primary-time {
        font-size: clamp(2.2rem, 3vw + 0.75rem, 2.8rem);
        font-weight: 700;
        letter-spacing: -0.04em;
      }

      /* Modern card styles */
      .glass-card {
        background: rgba(255, 255, 255, 0.7);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      @media (prefers-color-scheme: dark) {
        .glass-card {
          background: rgba(30, 41, 59, 0.7);
        }
      }

      .wake-display-section {
        margin-top: 0.5rem;
      }
      .wake-hero-card {
        position: relative;
        overflow: hidden;
      }

      .wake-hero-card::before {
        content: '';
        position: absolute;
        top: -50%;
        right: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
        animation: pulse 4s ease-in-out infinite;
      }

      .wake-hero-card::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100%;
        background: linear-gradient(135deg, transparent 30%, rgba(255, 255, 255, 0.1) 100%);
        pointer-events: none;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.05);
        }
      }

      .info-card {
        transition: all 0.3s ease;
      }

      .info-card:hover {
        transform: translateY(-4px);
      }

      .wake-time-display {
        position: relative;
        z-index: 1;
      }

      #timeBar > div {
        transition: flex-basis 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #timeBar > div span {
        white-space: nowrap;
        font-size: 0.75rem;
      }

      /* Hide labels when segment is too small */
      #timeBar > div[style*='display: none'] {
        width: 0;
        padding: 0;
        overflow: hidden;
      }
      .badge {
        font-size: 0.8rem;
        font-weight: 600;
        color: #1f3b82;
        background: #dbe4ff;
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
      }
      .secondary-time {
        font-size: 1rem;
        color: #52606d;
        font-weight: 600;
      }
      .totals,
      .breakdown {
        color: #61748f;
        font-weight: 500;
        font-size: 0.9rem;
      }
      .note {
        margin: 0.35rem 0 0;
        font-size: 0.85rem;
        color: #7d8ca2;
      }
      /* Awareness bar */
      .awareness {
        border-radius: 12px;
        background: linear-gradient(145deg, #f8fbff, #eef2f8);
        padding: 0.85rem 1rem;
        display: grid;
        gap: 0.6rem;
        margin-bottom: 0;
      }
      .aw-top {
        display: flex;
        gap: 0.6rem;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
      }
      .aw-where {
        font-size: 0.9rem;
        color: #1f3158;
        min-width: 0;
        flex: 1 1 auto;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 300px;
      }
      .aw-actions {
        display: flex;
        gap: 0.4rem;
        align-items: center;
      }
      .aw-actions input {
        width: 10rem;
        font: inherit;
        padding: 0.4rem 0.55rem;
        border: 1px solid #d2d8e1;
        border-radius: 8px;
        background: #fdfdff;
        font-size: 0.85rem;
      }
      /* Legacy tiny button no longer needed; kept for safety */
      .aw-grid {
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 0.5rem;
      }
      .aw-item {
        background: #ffffff;
        border: 1px solid #e5e9f2;
        border-radius: 10px;
        padding: 0.5rem 0.35rem;
        text-align: center;
      }
      .aw-item .label {
        font-size: 0.65rem;
        color: #61748f;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        line-height: 1.1;
      }
      .aw-item .value {
        font-size: 1.05rem;
        font-weight: 700;
        margin-top: 0.15rem;
        letter-spacing: -0.02em;
        line-height: 1.2;
      }
      .aw-item .value.bad {
        color: #b91c1c;
      }
      .aw-note {
        font-size: 0.85rem;
        color: #7d8ca2;
        margin: 0;
      }
      /* Inline clothes text */
      .inline-subtle {
        font-size: 1rem; /* slightly bigger for readability */
        color: #52606d;
        font-weight: 500;
      }
      .aw-credits {
        margin: 0.1rem 0 0;
        font-size: 0.65rem;
        color: #7d8ca2;
      }
      .aw-credits a {
        color: #1f3b82;
        text-decoration: underline;
      }
      @media (max-width: 640px) {
        .aw-grid {
          grid-template-columns: repeat(3, minmax(0, 1fr));
          gap: 0.4rem;
        }
        .aw-item {
          padding: 0.45rem 0.25rem;
        }
        .aw-item .label {
          font-size: 0.6rem;
        }
        .aw-item .value {
          font-size: 0.95rem;
        }
        .aw-actions {
          width: 100%;
        }
        .aw-actions input {
          flex: 1 1 auto;
          width: auto;
        }
        body {
          padding: 1rem;
        }
        main {
          padding: 0.5rem;
          gap: 0.5rem;
        }
        h1 {
          font-size: 1.4rem;
        }
        .actions {
          flex-direction: column;
        }
        button {
          width: 100%;
        }
      }
      @media (max-width: 480px) {
        .aw-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
    </style>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" />
  </head>
  <body>
    <div class="hero-bg" aria-hidden="true"></div>
    <main class="max-w-3xl w-full glass-main">
      <section
        class="awareness bg-base-200 rounded-2xl shadow-md"
        id="awareness"
        aria-live="polite"
      >
        <div class="aw-top flex items-center justify-start gap-2 flex-wrap">
          <div class="aw-where">
            <span id="awCity" class="badge badge-warning badge-outline text-xs md:text-sm"
              >Verify location</span
            >
          </div>
          <div
            class="aw-actions rounded-xl bg-base-100/70 border border-base-300 px-2 py-1 flex gap-2 flex-wrap"
          >
            <button type="button" id="useMyLocation" class="btn btn-primary btn-sm">
              Use my location
            </button>
            <input
              id="placeQuery"
              type="text"
              placeholder="City or ZIP"
              aria-label="City or ZIP"
              class="input input-bordered input-sm w-40"
            />
            <button type="button" id="setPlace" class="btn btn-ghost btn-sm">Set</button>
          </div>
        </div>

        <div class="aw-grid grid grid-cols-5 gap-2">
          <div class="aw-item rounded-xl bg-base-100 border border-base-300">
            <div class="label">Dawn</div>
            <time class="value" id="awDawn" datetime="">—</time>
          </div>
          <div class="aw-item rounded-xl bg-base-100 border border-base-300">
            <div class="label">Wind chill</div>
            <div class="value" id="awWindChill">—</div>
          </div>
          <div class="aw-item rounded-xl bg-base-100 border border-base-300">
            <div class="label">Precip %</div>
            <div class="value" id="awPoP">—</div>
          </div>
          <div class="aw-item rounded-xl bg-base-100 border border-base-300">
            <div class="label">Wet bulb</div>
            <div class="value" id="awWetBulb">—</div>
          </div>
          <div class="aw-item rounded-xl bg-base-100 border border-base-300">
            <div class="label">Trail Wetness</div>
            <div class="value" id="awWetness">—</div>
          </div>
        </div>

        <div class="aw-note" id="awMsg">
          Give location to load tomorrow's daylight &amp; conditions.
        </div>
        <p class="aw-credits">
          Powered by
          <a href="https://sunrisesunset.io" target="_blank" rel="noopener">SunriseSunset.io</a>
          &amp;
          <a href="https://open-meteo.com" target="_blank" rel="noopener">Open‑Meteo</a>
        </p>
      </section>

      <!-- Input Form Section -->
      <form id="wakeForm">
        <div class="form-row">
          <div class="field-group">
            <label for="firstMeeting">First meeting</label>
            <select
              id="firstMeeting"
              name="firstMeeting"
              required
              aria-required="true"
              class="select select-bordered w-full"
            >
              <option value="06:00">6:00 AM</option>
              <option value="06:15">6:15 AM</option>
              <option value="06:30">6:30 AM</option>
              <option value="06:45">6:45 AM</option>
              <option value="07:00">7:00 AM</option>
              <option value="07:15">7:15 AM</option>
              <option value="07:30">7:30 AM</option>
              <option value="07:45">7:45 AM</option>
              <option value="08:00">8:00 AM</option>
              <option value="08:15">8:15 AM</option>
              <option value="08:30" selected>8:30 AM</option>
              <option value="08:45">8:45 AM</option>
              <option value="09:00">9:00 AM</option>
              <option value="09:15">9:15 AM</option>
              <option value="09:30">9:30 AM</option>
              <option value="09:45">9:45 AM</option>
              <option value="10:00">10:00 AM</option>
            </select>
          </div>
          <div class="field-group">
            <label for="runMinutes">Run (minutes)</label>
            <input
              id="runMinutes"
              name="runMinutes"
              type="number"
              inputmode="numeric"
              min="0"
              placeholder="0"
              class="input input-bordered w-full"
            />
          </div>
        </div>

        <div class="form-row">
          <div class="field-group">
            <label for="breakfastMinutes">Breakfast</label>
            <select
              id="breakfastMinutes"
              name="breakfastMinutes"
              class="select select-bordered w-full"
            >
              <option value="0" selected>None (0 min)</option>
              <option value="10">Quick (10 min)</option>
              <option value="20">Standard (20 min)</option>
              <option value="45">Leisure w/ coffee (45 min)</option>
            </select>
          </div>
          <div class="field-group">
            <label for="runLocation"
              >Run location
              <span
                id="locHeadlamp"
                class="hidden ml-2 badge badge-error badge-outline text-[0.6rem] align-middle"
                >Check daylight</span
              ></label
            >
            <select id="runLocation" name="runLocation" class="select select-bordered w-full">
              <optgroup label="Dirt by distance">
                <option value="figure8" data-travel="14">Figure 8</option>
                <option value="huber" data-travel="20">Huber</option>
                <option value="tatum" data-travel="36">Tatum</option>
                <option value="holmdel" data-travel="50">Holmdel</option>
                <option value="shark-river" data-travel="52">Shark river</option>
                <option value="allaire" data-travel="64">Allaire</option>
                <option value="rez" data-travel="70">Rez</option>
                <option value="battlefield" data-travel="60">Battlefield</option>
              </optgroup>
              <optgroup label="No dirt">
                <option value="round-town" data-travel="0" selected>Round town</option>
                <option value="sandy-hook" data-travel="32">Sandy hook</option>
                <option value="henry-hudson" data-travel="32">Henry Hudson</option>
                <option value="lb-boardwalk" data-travel="38">LB Boardwalk</option>
                <option value="asbury-boardwalk" data-travel="50">Asbury boardwalk</option>
              </optgroup>
            </select>
          </div>
        </div>
        <!-- Travel time auto-synced with location (hidden, derived from data-travel attribute) -->
        <input id="travelMinutes" name="travelMinutes" type="hidden" value="0" />
        <!-- Hidden submit button for HTML validation -->
        <button type="submit" class="hidden" tabindex="-1">Submit</button>
      </form>

      <!-- Wake Time Display Section -->
      <section class="wake-display-section">
        <!-- Main Wake Time Card -->
        <div
          class="wake-hero-card rounded-3xl p-3 mb-3 text-center bg-gradient-to-br from-indigo-600 to-purple-600 text-white shadow-2xl relative overflow-hidden"
        >
          <div class="flex items-center justify-center gap-2 mb-2">
            <svg
              class="w-6 h-6 text-white/90"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
              ></path>
            </svg>
            <h1 class="text-lg md:text-xl font-bold text-white">Wake Time</h1>
          </div>
          <div class="wake-time-display">
            <div class="text-2xl md:text-3xl font-black text-white mb-1" id="chosenWake">--:--</div>
            <span id="prevDayBadge" class="badge badge-warning badge-sm align-middle hidden mb-2"
              >Previous day</span
            >
          </div>
        </div>

        <!-- Info Cards Grid -->
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 mb-4">
          <!-- Latest Wake Card -->
          <div
            class="info-card bg-white rounded-2xl p-4 shadow-lg border border-gray-100 hover:shadow-xl transition-all duration-300 flex flex-col"
          >
            <div class="flex items-center gap-2 mb-3">
              <div class="w-10 h-10 rounded-full bg-amber-100 flex items-center justify-center">
                <svg
                  class="w-5 h-5 text-amber-600"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                  ></path>
                </svg>
              </div>
              <div class="flex-1">
                <div class="text-xs text-gray-500 uppercase tracking-wider font-semibold">
                  Latest Wake
                </div>
                <div class="text-xl font-bold text-gray-900 mt-1" id="latestWake">--:--</div>
              </div>
            </div>
          </div>

          <!-- Run Start Card -->
          <div
            class="info-card bg-white rounded-2xl p-4 shadow-lg border border-gray-100 hover:shadow-xl transition-all duration-300 flex flex-col"
          >
            <div class="flex items-center gap-2 mb-3">
              <div class="w-10 h-10 rounded-full bg-green-100 flex items-center justify-center">
                <svg
                  class="w-5 h-5 text-green-600"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M13 10V3L4 14h7v7l9-11h-7z"
                  ></path>
                </svg>
              </div>
              <div class="flex-1">
                <div class="text-xs text-gray-500 uppercase tracking-wider font-semibold">
                  Run Start
                </div>
                <div class="text-xl font-bold text-gray-900 mt-1" id="runStart">--:--</div>
              </div>
            </div>
          </div>

          <!-- Clothes Card -->
          <div
            class="info-card bg-white rounded-2xl p-4 shadow-lg border border-gray-100 hover:shadow-xl transition-all duration-300 flex flex-col"
          >
            <div class="flex items-center gap-2 mb-3">
              <div class="w-10 h-10 rounded-full bg-blue-100 flex items-center justify-center">
                <svg
                  class="w-5 h-5 text-blue-600"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"
                  ></path>
                </svg>
              </div>
              <div class="flex-1">
                <div class="text-xs text-gray-500 uppercase tracking-wider font-semibold">
                  Attire
                </div>
                <div class="text-base font-bold text-gray-900 mt-1" id="clothesInline">—</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Time Breakdown Bar -->
        <div class="bg-white rounded-2xl p-4 shadow-lg border border-gray-100">
          <h3 class="text-xs text-gray-500 uppercase tracking-wider font-semibold mb-3">
            Time Allocation
          </h3>
          <div class="relative">
            <div class="flex rounded-full overflow-hidden h-10 bg-gray-100 mb-3" id="timeBar">
              <div
                class="bg-gradient-to-r from-green-500 to-green-600 flex items-center justify-center text-xs font-semibold text-white transition-all duration-500 relative overflow-hidden"
                id="runBar"
                style="flex-basis: 20%"
              >
                <span class="relative z-10 drop-shadow" id="runBarText">Run</span>
              </div>
              <div
                class="bg-gradient-to-r from-indigo-500 to-indigo-600 flex items-center justify-center text-xs font-semibold text-white transition-all duration-500 relative overflow-hidden"
                id="prepBar"
                style="flex-basis: 30%"
              >
                <span class="relative z-10 drop-shadow">Prep 45m</span>
              </div>
              <div
                class="bg-gradient-to-r from-amber-500 to-amber-600 flex items-center justify-center text-xs font-semibold text-white transition-all duration-500 relative overflow-hidden"
                id="travelBar"
                style="flex-basis: 20%"
              >
                <span class="relative z-10 drop-shadow" id="travelBarText">Travel</span>
              </div>
              <div
                class="bg-gradient-to-r from-cyan-500 to-cyan-600 flex items-center justify-center text-xs font-semibold text-white transition-all duration-500 relative overflow-hidden"
                id="breakfastBar"
                style="flex-basis: 30%"
              >
                <span class="relative z-10 drop-shadow" id="breakfastBarText">Breakfast</span>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
    <script>
      (() => {
        // Constants
        const PREP_MINUTES = 45; // Fixed prep time - not user-configurable by design
        const PREP_BEFORE_RUN = 20; // Portion of prep before leaving for run
        const MINUTES_PER_DAY = 1440;
        const MINUTES_PER_HOUR = 60;
        const MM_TO_INCHES = 25.4;

        const defaults = {
          firstMeeting: '08:30',
          run: '',
          prep: String(PREP_MINUTES),
          travel: '0',
          breakfast: '0',
          location: 'round-town',
        };

        const storageKeys = {
          firstMeeting: 'wake:first',
          run: 'wake:run',
          travel: 'wake:travel',
          breakfast: 'wake:breakfast',
          location: 'wake:location',
        };

        const elements = {
          form: document.getElementById('wakeForm'),
          first: document.getElementById('firstMeeting'),
          run: document.getElementById('runMinutes'),
          travel: document.getElementById('travelMinutes'),
          breakfast: document.getElementById('breakfastMinutes'),
          location: document.getElementById('runLocation'),
          latestWake: document.getElementById('latestWake'),
          chosenWake: document.getElementById('chosenWake'),
          runStart: document.getElementById('runStart'),
        };

        const toMinutes = (time) => {
          if (typeof time !== 'string' || !time.includes(':')) return null;
          const [h, m] = time.split(':').map(Number);
          if (Number.isNaN(h) || Number.isNaN(m)) return null;
          return h * MINUTES_PER_HOUR + m;
        };

        const fromMinutes = (total) => {
          const minutes = ((total % MINUTES_PER_DAY) + MINUTES_PER_DAY) % MINUTES_PER_DAY;
          const h = Math.floor(minutes / MINUTES_PER_HOUR);
          const m = minutes % MINUTES_PER_HOUR;
          return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
        };

        const format12 = (time24) => {
          const [h, m] = time24.split(':').map(Number);
          const period = h >= 12 ? 'PM' : 'AM';
          const hour = h % 12 === 0 ? 12 : h % 12;
          return `${hour}:${String(m).padStart(2, '0')} ${period}`;
        };

        const sanitizeMinutes = (value, fallback) => {
          if (value === '' || value === null || value === undefined) return fallback;
          const number = Number.parseInt(value, 10);
          return Number.isNaN(number) ? fallback : Math.max(0, number);
        };

        // (removed unused helpers minutesLabel, setStatus)

        const setFirstMeeting = (value) => {
          const option = elements.first.querySelector(`option[value="${value}"]`);
          elements.first.value = option ? value : defaults.firstMeeting;
        };

        const loadValues = () => {
          const stored = Object.fromEntries(
            Object.entries(storageKeys).map(([key, storageKey]) => {
              try {
                return [key, localStorage.getItem(storageKey)];
              } catch (error) {
                return [key, null];
              }
            })
          );

          setFirstMeeting(stored.firstMeeting ?? defaults.firstMeeting);
          // Use saved location if present; otherwise default
          setRunLocation(stored.location ?? defaults.location);
          elements.run.value = stored.run ?? defaults.run;
          // prep fixed at PREP_MINUTES
          elements.breakfast.value = stored.breakfast ?? defaults.breakfast;

          // Always sync travel with location
          syncTravelWithLocation();
        };

        const saveValues = () => {
          try {
            localStorage.setItem(
              storageKeys.firstMeeting,
              elements.first.value || defaults.firstMeeting
            );
            localStorage.setItem(storageKeys.run, elements.run.value);
            localStorage.setItem(storageKeys.travel, elements.travel.value || defaults.travel);
            localStorage.setItem(
              storageKeys.breakfast,
              elements.breakfast.value || defaults.breakfast
            );
            localStorage.setItem(
              storageKeys.location,
              elements.location.value || defaults.location
            );
          } catch (error) {
            console.error('Local storage unavailable', error);
          }
        };

        const setRunLocation = (value) => {
          const option = elements.location.querySelector(`option[value="${value}"]`);
          elements.location.value = option ? value : defaults.location;
        };

        const syncTravelWithLocation = () => {
          const option = elements.location.options[elements.location.selectedIndex];
          const auto = option ? Number(option.dataset.travel) : NaN;
          if (Number.isFinite(auto)) {
            elements.travel.value = String(auto);
          }
        };

        const weatherStorage = {
          lat: 'wake:lat',
          lon: 'wake:lon',
          city: 'wake:city',
          tz: 'wake:tz',
        };

        // Simple cache (15 min)
        const CACHE_DURATION = 15 * 60 * 1000;
        const weatherCache = {};

        const wels = {
          awCity: document.getElementById('awCity'),
          awDawn: document.getElementById('awDawn'),
          awWindChill: document.getElementById('awWindChill'),
          awPoP: document.getElementById('awPoP'),
          awWetBulb: document.getElementById('awWetBulb'),
          awWetness: document.getElementById('awWetness'),
          awMsg: document.getElementById('awMsg'),
          useLoc: document.getElementById('useMyLocation'),
          placeInput: document.getElementById('placeQuery'),
          setPlace: document.getElementById('setPlace'),
          clothes: document.getElementById('clothesInline'),
        };

        const defaultTz = Intl.DateTimeFormat().resolvedOptions().timeZone;

        // Explicit list of dirt locations (robust across browsers)
        const DIRT_LOCATIONS = new Set([
          'figure8',
          'huber',
          'tatum',
          'holmdel',
          'shark-river',
          'allaire',
          'rez',
          'battlefield',
        ]);
        // Store dawn date globally for daylight check
        let currentDawnDate = null;

        // Check if we need daylight warning based on run start time vs dawn
        const updateLocationHeadlamp = () => {
          const badge = document.getElementById('locHeadlamp');

          if (!currentDawnDate) {
            if (badge) badge.classList.add('hidden');
            return;
          }

          // Calculate run start time
          const firstValue = elements.first.value || defaults.firstMeeting;
          const firstMinutes = toMinutes(firstValue);
          if (firstMinutes === null) {
            if (badge) badge.classList.add('hidden');
            return;
          }

          const run = sanitizeMinutes(elements.run.value, 0);
          const travel = sanitizeMinutes(elements.travel.value, 0);
          const breakfast = sanitizeMinutes(elements.breakfast.value, 0);

          const total = run + PREP_MINUTES + travel + breakfast;
          let wake = firstMinutes - total;
          if (wake < 0) wake += MINUTES_PER_DAY;

          const runStartMinutes = wake + PREP_BEFORE_RUN + Math.floor(travel / 2); // Half travel for one-way

          // Get dawn time in minutes
          const dawnHours = currentDawnDate.getHours();
          const dawnMins = currentDawnDate.getMinutes();
          const dawnTotalMinutes = dawnHours * 60 + dawnMins;

          // Calculate difference (no buffer)
          const minutesFromDawn = (runStartMinutes % MINUTES_PER_DAY) - dawnTotalMinutes;

          // Only show warning if running at or before dawn
          if (minutesFromDawn <= 0) {
            // Running at or before dawn (dark)
            const minBefore = Math.abs(minutesFromDawn);
            if (badge) {
              badge.classList.remove('hidden');
              if (minBefore === 0) {
                badge.textContent = `Check daylight (at dawn)`;
              } else {
                badge.textContent = `Check daylight (${minBefore} min before dawn)`;
              }
            }
          } else {
            // Running after dawn, no warning needed
            if (badge) badge.classList.add('hidden');
          }
        };

        const fmtTime12InZone = (date, tz) =>
          new Intl.DateTimeFormat(undefined, {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true,
            timeZone: tz,
          }).format(date);

        const fmtYMDInZone = (date, tz) =>
          new Intl.DateTimeFormat('en-CA', {
            timeZone: tz,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
          }).format(date);

        const fToC = (f) => ((f - 32) * 5) / 9;
        const cToF = (c) => (c * 9) / 5 + 32;

        const stullWetBulbC = (tempC, rh) => {
          const sqrt = Math.sqrt(rh + 8.313659);
          const term1 = Math.atan(0.151977 * sqrt);
          const term2 = Math.atan(tempC + rh);
          const term3 = Math.atan(rh - 1.676331);
          const term4 = 0.00391838 * Math.pow(rh, 1.5) * Math.atan(0.023101 * rh);
          return tempC * term1 + term2 - term3 + term4 - 4.686035;
        };

        const windChillF = (tempF, windMph) => {
          if (tempF <= 50 && windMph >= 3) {
            const v16 = Math.pow(windMph, 0.16);
            return 35.74 + 0.6215 * tempF - 35.75 * v16 + 0.4275 * tempF * v16;
          }
          return null;
        };

        const clothesSuggestion = (f) => {
          if (f == null || Number.isNaN(f)) return null;
          if (f >= 55) return 'Standard';
          if (f >= 50) return 'Shorts + tee + light gloves';
          if (f >= 45) return 'Shorts + long‑sleeve + gloves';
          if (f >= 30) return 'Shorts + long‑sleeve + gloves + headband';
          if (f >= 20) return 'Pants + long‑sleeve + gloves + headband';
          return 'Pants + long‑sleeve + jacket + gloves + headband';
        };

        // Trail Wetness Score (decayed rain minus ET0)
        const wetnessConfig = {
          decay: 0.85, // per day
          dryFactor: 0.6, // portion of ET0 (inches) to subtract per day
          lookbackDays: 7,
        };

        // Fetch daily rain & ET0 for recent days; use inches and local timezone
        const fetchWetnessInputs = async (lat, lon, dawnLocalDate, tz) => {
          const dawnYMD = fmtYMDInZone(dawnLocalDate, tz || defaultTz);
          const key = `wetness_${lat}_${lon}_${dawnYMD}`;
          return fetchWithCache(key, async () => {
            const params = new URLSearchParams({
              latitude: lat,
              longitude: lon,
              daily: ['precipitation_sum', 'et0_fao_evapotranspiration'].join(','),
              precipitation_unit: 'inch',
              timezone: tz || 'auto',
              past_days: String(Math.max(7, wetnessConfig.lookbackDays + 1)),
            });
            const url = `https://api.open-meteo.com/v1/forecast?${params}`;
            const r = await fetch(url);
            if (!r.ok) throw new Error('wetness daily fetch failed');
            const j = await r.json();

            // Keep only days strictly BEFORE the dawn day (we're judging surface state going into dawn)
            const dawnYMD = fmtYMDInZone(dawnLocalDate, tz || defaultTz);
            const times = j.daily?.time || [];
            const P = j.daily?.precipitation_sum || [];
            const ET0mm = j.daily?.et0_fao_evapotranspiration || [];
            const ET0in = ET0mm.map((v) => (typeof v === 'number' ? v / MM_TO_INCHES : null));

            const rows = [];
            for (let i = 0; i < times.length; i++) {
              const dayStr = times[i]; // YYYY-MM-DD in requested tz
              if (typeof dayStr === 'string' && dayStr < dawnYMD) {
                rows.push({ date: dayStr, rainIn: P[i] ?? 0, et0In: ET0in[i] ?? 0 });
              }
            }
            return rows.slice(-wetnessConfig.lookbackDays); // last N days up to yesterday
          });
        };

        const computeWetness = (rows) => {
          // rows ordered oldest..newest -> reverse for i=0=most recent (yesterday)
          const r = [...rows].reverse();
          let wetness = 0;
          for (let i = 0; i < r.length; i++) {
            const day = r[i];
            const eff = Math.max(0, (day.rainIn || 0) - wetnessConfig.dryFactor * (day.et0In || 0));
            wetness += eff * Math.pow(wetnessConfig.decay, i);
          }
          return Math.max(0, wetness);
        };

        const categorizeWetness = (wetnessIn) => {
          if (wetnessIn < 0.05) return { label: 'Dry', idx: 0 };
          if (wetnessIn < 0.2) return { label: 'Moist', idx: 1 };
          if (wetnessIn < 0.4) return { label: 'Slick', idx: 2 };
          if (wetnessIn < 0.8) return { label: 'Muddy', idx: 3 };
          return { label: 'Soaked', idx: 4 };
        };

        const nearestIndex = (times, target) => {
          const targetMs = target.getTime();
          let best = 0;
          let bestDiff = Infinity;
          for (let i = 0; i < times.length; i += 1) {
            const t = times[i];
            const timeMs = typeof t === 'number' ? t * 1000 : new Date(t).getTime();
            const diff = Math.abs(timeMs - targetMs);
            if (diff < bestDiff) {
              best = i;
              bestDiff = diff;
            }
          }
          return best;
        };

        // Utilities for place labels
        const US_STATE_ABBR = {
          Alabama: 'AL',
          Alaska: 'AK',
          Arizona: 'AZ',
          Arkansas: 'AR',
          California: 'CA',
          Colorado: 'CO',
          Connecticut: 'CT',
          Delaware: 'DE',
          Florida: 'FL',
          Georgia: 'GA',
          Hawaii: 'HI',
          Idaho: 'ID',
          Illinois: 'IL',
          Indiana: 'IN',
          Iowa: 'IA',
          Kansas: 'KS',
          Kentucky: 'KY',
          Louisiana: 'LA',
          Maine: 'ME',
          Maryland: 'MD',
          Massachusetts: 'MA',
          Michigan: 'MI',
          Minnesota: 'MN',
          Mississippi: 'MS',
          Missouri: 'MO',
          Montana: 'MT',
          Nebraska: 'NE',
          Nevada: 'NV',
          'New Hampshire': 'NH',
          'New Jersey': 'NJ',
          'New Mexico': 'NM',
          'New York': 'NY',
          'North Carolina': 'NC',
          'North Dakota': 'ND',
          Ohio: 'OH',
          Oklahoma: 'OK',
          Oregon: 'OR',
          Pennsylvania: 'PA',
          'Rhode Island': 'RI',
          'South Carolina': 'SC',
          'South Dakota': 'SD',
          Tennessee: 'TN',
          Texas: 'TX',
          Utah: 'UT',
          Vermont: 'VT',
          Virginia: 'VA',
          Washington: 'WA',
          'West Virginia': 'WV',
          Wisconsin: 'WI',
          Wyoming: 'WY',
          'District of Columbia': 'DC',
        };

        const abbrUS = (admin1, isoSub) => {
          if (isoSub && /^US-/.test(isoSub)) return isoSub.split('-')[1];
          return US_STATE_ABBR[admin1] || admin1 || 'US';
        };

        const formatPlaceLabel = ({ name, admin1, country, country_code, iso_sub }) => {
          const cc = (country_code || '').toUpperCase();
          if (cc === 'US') {
            const st = abbrUS(admin1, iso_sub);
            return name
              ? `${name}, ${st}`
              : admin1
                ? `${abbrUS(admin1, iso_sub)}, US`
                : 'United States';
          }
          if (name && cc) return `${name}, ${cc}`;
          if (name && country) return `${name}, ${country}`;
          return name || admin1 || country || 'Location';
        };

        const geocodePlace = async (name) => {
          const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(name)}&count=1&language=en&format=json`;
          const res = await fetch(url);
          if (!res.ok) throw new Error('geocoding failed');
          const data = await res.json();
          if (!data.results || !data.results.length) throw new Error('place not found');
          const match = data.results[0];
          const city = formatPlaceLabel({
            name: match.name,
            admin1: match.admin1,
            country: match.country,
            country_code: match.country_code,
          });
          return {
            lat: match.latitude,
            lon: match.longitude,
            city,
            tz: match.timezone || defaultTz,
          };
        };

        const reverseGeocode = async (lat, lon) => {
          // Try Open‑Meteo reverse first (if/when available for this point)
          try {
            const url = `https://geocoding-api.open-meteo.com/v1/reverse?latitude=${lat}&longitude=${lon}&language=en&count=1&format=json`;
            const res = await fetch(url);
            if (res.ok) {
              const data = await res.json();
              const r = data.results?.[0];
              if (r) {
                const city = formatPlaceLabel({
                  name: r.name,
                  admin1: r.admin1,
                  country: r.country,
                  country_code: r.country_code,
                });
                return { city, tz: r.timezone };
              }
            }
          } catch {}

          // Fallback to Nominatim (OSM)
          try {
            const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`;
            const res = await fetch(url, { headers: { Accept: 'application/json' } });
            if (!res.ok) throw new Error('nominatim failed');
            const data = await res.json();
            const a = data.address || {};
            const locality = a.city || a.town || a.village || a.hamlet || a.suburb || a.county;
            const region = a.state || a.region || a.province || a.county;
            const country = a.country;
            const city = formatPlaceLabel({
              name: locality,
              admin1: region,
              country,
              country_code: (a.country_code || '').toUpperCase(),
              iso_sub: a['ISO3166-2-lvl4'] || a['ISO3166-2-lvl3'] || '',
            });
            return { city };
          } catch {}

          // Last resort: coordinates string
          return { city: `${lat.toFixed(4)}, ${lon.toFixed(4)}` };
        };

        const saveCoords = (lat, lon, city, tz) => {
          try {
            localStorage.setItem(weatherStorage.lat, String(lat));
            localStorage.setItem(weatherStorage.lon, String(lon));
            if (city) localStorage.setItem(weatherStorage.city, city);
            if (tz) localStorage.setItem(weatherStorage.tz, tz);
          } catch (error) {
            console.warn('Unable to save coordinates', error);
          }
        };

        const readCoords = () => {
          try {
            const lat = parseFloat(localStorage.getItem(weatherStorage.lat));
            const lon = parseFloat(localStorage.getItem(weatherStorage.lon));
            const city = localStorage.getItem(weatherStorage.city) || '';
            const tz = localStorage.getItem(weatherStorage.tz) || defaultTz;
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            return { lat, lon, city, tz };
          } catch (error) {
            return null;
          }
        };

        const fetchWithCache = async (key, fetcher, signal = null) => {
          let stale;

          // Check localStorage cache first
          try {
            const raw = localStorage.getItem(key);
            const time = Number(localStorage.getItem(key + ':t'));
            if (raw) stale = JSON.parse(raw);
            if (raw && time && Date.now() - time < CACHE_DURATION) {
              return stale; // Fresh enough
            }
          } catch {}

          // Check in-memory cache
          const cached = weatherCache[key];
          if (cached) {
            if (!stale) stale = cached.data;
            if (Date.now() - cached.time < CACHE_DURATION) {
              return cached.data; // Fresh enough
            }
          }

          // Try to fetch fresh data
          try {
            const data = await fetcher(signal);

            // Update both caches
            weatherCache[key] = { data, time: Date.now() };
            try {
              localStorage.setItem(key, JSON.stringify(data));
              localStorage.setItem(key + ':t', String(Date.now()));
            } catch {}

            return data;
          } catch (error) {
            // If fetch fails and we have stale data, return it
            if (stale) return stale;
            throw error; // No stale data available, re-throw error
          }
        };

        const tomorrowYMD = (tz) =>
          new Intl.DateTimeFormat('en-CA', {
            timeZone: tz,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
          }).format(new Date(Date.now() + 24 * 60 * 60 * 1000));

        const fetchDawn = async (lat, lon, tz = defaultTz, signal = null) => {
          const ymd = tomorrowYMD(tz);
          return fetchWithCache(`dawn_${lat}_${lon}_${ymd}`, async (signal) => {
            const url = `https://api.sunrisesunset.io/json?lat=${lat}&lng=${lon}&date=tomorrow&time_format=unix`;
            const res = await fetch(url, signal ? { signal } : {});
            if (!res.ok) throw new Error('dawn fetch failed');
            const data = await res.json();
            if (!data.results || data.status !== 'OK') throw new Error('no dawn results');
            const dawnEpoch = data.results.dawn;
            return new Date(dawnEpoch * 1000);
          });
        };

        const fetchWeatherAround = async (lat, lon, whenLocal, tz) => {
          const hrKey = `hourly_${lat}_${lon}_${Math.floor(
            whenLocal.getTime() / (60 * 60 * 1000)
          )}`;
          return fetchWithCache(hrKey, async () => {
            const params = new URLSearchParams({
              latitude: lat,
              longitude: lon,
              hourly:
                'temperature_2m,relative_humidity_2m,wind_speed_10m,apparent_temperature,precipitation_probability,wet_bulb_temperature_2m,weathercode,snowfall',
              temperature_unit: 'fahrenheit',
              wind_speed_unit: 'mph',
              timezone: tz || 'auto',
              timeformat: 'unixtime',
            });
            const url = `https://api.open-meteo.com/v1/forecast?${params.toString()}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error('weather fetch failed');
            const data = await res.json();

            const index = nearestIndex(data.hourly.time, whenLocal);
            const tempF = data.hourly.temperature_2m?.[index];
            const rh = data.hourly.relative_humidity_2m?.[index];
            const windMph = data.hourly.wind_speed_10m?.[index];
            const pop = data.hourly.precipitation_probability?.[index];
            const weatherCode = data.hourly.weathercode?.[index];
            const snowfall = data.hourly.snowfall?.[index];
            let wetBulbF = data.hourly.wet_bulb_temperature_2m?.[index];
            const wetUnit = data.hourly_units?.wet_bulb_temperature_2m || '°F';
            if (wetBulbF != null && /°C/i.test(wetUnit)) {
              wetBulbF = cToF(wetBulbF);
            }
            if ((wetBulbF == null || Number.isNaN(wetBulbF)) && tempF != null && rh != null) {
              wetBulbF = cToF(stullWetBulbC(fToC(tempF), rh));
            }
            const windChill = tempF != null && windMph != null ? windChillF(tempF, windMph) : null;
            const snowCodes = new Set([
              71,
              73,
              75,
              77, // snow
              85,
              86, // snow showers
            ]);
            const isSnow =
              (typeof weatherCode === 'number' && snowCodes.has(weatherCode)) ||
              (typeof snowfall === 'number' && snowfall > 0);
            return { tempF, rh, windMph, pop, wetBulbF, windChillF: windChill, isSnow };
          });
        };

        const renderAwareness = ({
          tz,
          city,
          dawn,
          windChillF,
          pop,
          wetBulbF,
          tempF,
          windMph,
          wetnessLabel,
          wetnessValue,
          isSnow,
        }) => {
          if (!wels.awCity) return;
          wels.awCity.textContent = city || 'Verify location';
          wels.awCity.title = city || ''; // Add tooltip for full name

          // Update badge color: green when resolved, yellow when verifying
          if (city && city !== 'Verify location') {
            wels.awCity.className = 'badge badge-success badge-outline text-xs md:text-sm';
          } else {
            wels.awCity.className = 'badge badge-warning badge-outline text-xs md:text-sm';
          }
          if (dawn) {
            wels.awDawn.textContent = fmtTime12InZone(dawn, tz || defaultTz);
            wels.awDawn.setAttribute('datetime', dawn.toISOString());
            wels.awDawn.title = `Around dawn local time (${tz || defaultTz})`;
          } else {
            wels.awDawn.textContent = '—';
            wels.awDawn.removeAttribute('datetime');
          }

          let windText = '—';
          if (windChillF != null) {
            windText = `${Math.round(windChillF)}°F`;
          } else if (typeof tempF === 'number') {
            const tempLabel = `${Math.round(tempF)}°F`;
            if (typeof windMph === 'number' && windMph < 3) {
              windText = `${tempLabel} (calm)`;
            } else if (typeof windMph === 'number') {
              windText = tempLabel;
            } else {
              windText = tempLabel;
            }
          }
          wels.awWindChill.textContent = windText;
          // Threshold: 15°F or colder is bad (use wind chill if available)
          wels.awWindChill.classList.remove('bad');
          const windMetric =
            typeof windChillF === 'number' ? windChillF : typeof tempF === 'number' ? tempF : null;
          if (windMetric != null && windMetric <= 15) {
            wels.awWindChill.classList.add('bad');
          }

          // Clothing suggestion based on wind chill/temperature
          let reco = clothesSuggestion(windMetric);
          if (reco && typeof pop === 'number' && pop >= 60 && !isSnow) {
            reco += ' + rain jacket';
          }
          if (wels.clothes) wels.clothes.textContent = reco || '—';

          wels.awPoP.textContent =
            typeof pop === 'number' && pop >= 0 ? `${Math.round(pop)}%` : '—';
          wels.awPoP.title = 'Probability of precip for the hour around dawn';
          // Threshold: 60% or higher is bad
          wels.awPoP.classList.remove('bad');
          if (typeof pop === 'number' && pop >= 60) {
            wels.awPoP.classList.add('bad');
          }
          wels.awWetBulb.textContent =
            typeof wetBulbF === 'number' ? `${Math.round(wetBulbF)}°F` : '—';
          // Threshold: 75°F or higher is bad
          wels.awWetBulb.classList.remove('bad');
          if (typeof wetBulbF === 'number' && wetBulbF >= 75) {
            wels.awWetBulb.classList.add('bad');
          }
          wels.awWetness.textContent = wetnessLabel || '—';
          // Threshold: 0.40" or higher is bad
          wels.awWetness.classList.remove('bad');
          if (typeof wetnessValue === 'number' && wetnessValue >= 0.4) {
            wels.awWetness.classList.add('bad');
          }

          // Store dawn for daylight check
          currentDawnDate = dawn;
          updateLocationHeadlamp();
        };

        // Track request IDs to prevent stale responses
        let awReqId = 0;
        let awAbort;

        const refreshAwareness = async (lat, lon, city = '', tz = defaultTz) => {
          if (!wels.awMsg) return;

          // Abort previous request
          awAbort?.abort();
          awAbort = new AbortController();
          const { signal } = awAbort;

          const id = ++awReqId;
          try {
            wels.awMsg.textContent = 'Loading…';

            // Fetch dawn first
            const dawnDate = await fetchDawn(lat, lon, tz, signal);

            // Parallel fetch weather & wetness
            const [weather, wetnessInfo] = await Promise.all([
              fetchWeatherAround(lat, lon, dawnDate, tz),
              fetchWetnessInputs(lat, lon, dawnDate, tz)
                .then((rows) => {
                  const value = computeWetness(rows);
                  const { label } = categorizeWetness(value);
                  return { label, value };
                })
                .catch(() => ({ label: '—', value: null })),
            ]);

            // Ignore stale responses
            if (id !== awReqId) return;

            const wetnessLabel =
              wetnessInfo.value != null
                ? `${wetnessInfo.label} (${wetnessInfo.value.toFixed(2)}")`
                : wetnessInfo.label;

            renderAwareness({
              tz,
              city,
              dawn: dawnDate,
              windChillF: weather.windChillF,
              pop: weather.pop,
              wetBulbF: weather.wetBulbF,
              tempF: weather.tempF,
              windMph: weather.windMph,
              wetnessLabel,
              wetnessValue: wetnessInfo.value,
              isSnow: weather.isSnow,
            });
            wels.awMsg.textContent = '';
          } catch (error) {
            if (error.name === 'AbortError') return; // Request was cancelled
            console.error(error);
            if (id === awReqId) {
              wels.awMsg.textContent = 'Failed to load conditions.';
            }
          }
        };

        const attachAwarenessEvents = () => {
          wels.useLoc?.addEventListener('click', () => {
            if (!navigator.geolocation) {
              wels.awMsg.textContent = 'Geolocation not supported.';
              return;
            }
            wels.awMsg.textContent = 'Getting location…';
            navigator.geolocation.getCurrentPosition(
              async (pos) => {
                const { latitude, longitude } = pos.coords;
                try {
                  const info = await reverseGeocode(latitude, longitude);
                  const label = info.city || `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                  const tz = info.tz || defaultTz;
                  saveCoords(latitude, longitude, label, tz);
                  await refreshAwareness(latitude, longitude, label, tz);
                } catch (error) {
                  console.warn('Reverse geocoding failed:', error);
                  const fallback = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                  saveCoords(latitude, longitude, fallback, defaultTz);
                  await refreshAwareness(latitude, longitude, fallback, defaultTz);
                }
              },
              (err) => {
                console.warn(err);
                wels.awMsg.textContent = 'Location denied.';
              },
              { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
            );
          });

          wels.setPlace?.addEventListener('click', async () => {
            const query = (wels.placeInput?.value || '').trim();
            if (!query) return;
            try {
              wels.awMsg.textContent = 'Looking up…';
              const loc = await geocodePlace(query);
              saveCoords(loc.lat, loc.lon, loc.city, loc.tz);
              await refreshAwareness(loc.lat, loc.lon, loc.city, loc.tz);
            } catch (error) {
              console.error(error);
              wels.awMsg.textContent = 'Not found.';
            }
          });

          // Add Enter key support for place input
          wels.placeInput?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              wels.setPlace?.click();
            }
          });
        };

        const initAwareness = async () => {
          if (!document.getElementById('awareness')) return;
          attachAwarenessEvents();
          const saved = readCoords();
          if (saved) {
            await refreshAwareness(saved.lat, saved.lon, saved.city, saved.tz);
          } else if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              async (pos) => {
                const { latitude, longitude } = pos.coords;
                // Try reverse geocode silently on startup
                try {
                  const info = await reverseGeocode(latitude, longitude);
                  const label = info.city || `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                  const tz = info.tz || defaultTz;
                  saveCoords(latitude, longitude, label, tz);
                  await refreshAwareness(latitude, longitude, label, tz);
                } catch (error) {
                  console.warn('Silent reverse geocoding failed:', error);
                  const fallback = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
                  saveCoords(latitude, longitude, fallback, defaultTz);
                  await refreshAwareness(latitude, longitude, fallback, defaultTz);
                }
              },
              () => {},
              { enableHighAccuracy: true, timeout: 5000, maximumAge: 60000 }
            );
          }
        };

        const renderResult = (wakeMinutes, totalMinutes, prevDay, durations) => {
          const wake24 = fromMinutes(wakeMinutes);
          const wake12 = format12(wake24);

          // Calculate latest wake (meeting - prep - run only, no breakfast/travel)
          const firstValue = elements.first.value || defaults.firstMeeting;
          const firstMinutes = toMinutes(firstValue);
          const latestWakeMinutes = firstMinutes - (durations.run + PREP_MINUTES);
          const latest24 = fromMinutes(
            latestWakeMinutes < 0 ? latestWakeMinutes + MINUTES_PER_DAY : latestWakeMinutes
          );
          const latest12 = format12(latest24);

          elements.latestWake.textContent = latest12;
          elements.chosenWake.textContent = wake12;

          // Show/hide previous day badge
          const badge = document.getElementById('prevDayBadge');
          if (badge) {
            if (prevDay) badge.classList.remove('hidden');
            else badge.classList.add('hidden');
          }

          // Update run start time (wake + prep portion + half travel for one-way)
          const runStartMinutes = wakeMinutes + PREP_BEFORE_RUN + Math.floor(durations.travel / 2);
          const runStart12 = format12(fromMinutes(runStartMinutes));
          if (elements.runStart) elements.runStart.textContent = runStart12;

          // Legacy run start time element (if exists)
          const runStartEl = document.getElementById('runStartTime');
          if (runStartEl) runStartEl.textContent = runStart12;

          // Update run duration text
          const runDurationEl = document.getElementById('runDuration');
          if (runDurationEl) runDurationEl.textContent = `${durations.run} min run`;

          // Update bar text with minutes
          const runBarText = document.getElementById('runBarText');
          if (runBarText)
            runBarText.textContent = durations.run > 0 ? `Run ${durations.run}m` : 'Run';

          const travelBarText = document.getElementById('travelBarText');
          if (travelBarText)
            travelBarText.textContent =
              durations.travel > 0 ? `Travel ${durations.travel}m` : 'Travel';

          const breakfastBarText = document.getElementById('breakfastBarText');
          if (breakfastBarText)
            breakfastBarText.textContent =
              durations.breakfast > 0 ? `Breakfast ${durations.breakfast}m` : 'Breakfast';

          // Update breakdown (if element still exists for backwards compatibility)
          const breakdownEl = document.getElementById('breakdown');
          if (breakdownEl) {
            breakdownEl.textContent = `${durations.run} (run) + ${PREP_MINUTES} (prep) + ${durations.travel} (travel) + ${durations.breakfast} (breakfast)`;
          }

          // Update visual bars
          const total = durations.run + PREP_MINUTES + durations.travel + durations.breakfast;
          if (total > 0) {
            const runBar = document.getElementById('runBar');
            const prepBar = document.getElementById('prepBar');
            const travelBar = document.getElementById('travelBar');
            const breakfastBar = document.getElementById('breakfastBar');

            if (runBar) runBar.style.flexBasis = `${(durations.run / total) * 100}%`;
            if (prepBar) prepBar.style.flexBasis = `${(PREP_MINUTES / total) * 100}%`;
            if (travelBar) {
              if (durations.travel > 0) {
                travelBar.style.flexBasis = `${(durations.travel / total) * 100}%`;
                travelBar.style.display = 'flex';
              } else {
                travelBar.style.display = 'none';
              }
            }
            if (breakfastBar) {
              if (durations.breakfast > 0) {
                breakfastBar.style.flexBasis = `${(durations.breakfast / total) * 100}%`;
                breakfastBar.style.display = 'flex';
              } else {
                breakfastBar.style.display = 'none';
              }
            }
          }
        };

        const showEmptyState = () => {
          elements.latestWake.textContent = '--:--';
          elements.chosenWake.textContent = '--:--';

          const runStartEl = document.getElementById('runStartTime');
          if (runStartEl) runStartEl.textContent = '--:--';

          const runDurationEl = document.getElementById('runDuration');
          if (runDurationEl) runDurationEl.textContent = '0 min run';

          const breakdownEl = document.getElementById('breakdown');
          if (breakdownEl) {
            breakdownEl.textContent = `0 (run) + ${PREP_MINUTES} (prep) + 0 (travel) + 0 (breakfast)`;
          }
        };

        const recalculate = () => {
          const firstValue = elements.first.value || defaults.firstMeeting;
          const firstMinutes = toMinutes(firstValue);
          if (firstMinutes === null) {
            showEmptyState();
            return;
          }
          const run = sanitizeMinutes(elements.run.value, 0);
          const prep = PREP_MINUTES;
          const travel = sanitizeMinutes(elements.travel.value, 0);
          const breakfast = sanitizeMinutes(elements.breakfast.value, 0);

          const total = run + prep + travel + breakfast;
          let wake = firstMinutes - total;
          let previousDay = false;
          if (wake < 0) {
            wake += MINUTES_PER_DAY;
            previousDay = true;
          }

          renderResult(wake, total, previousDay, { run, travel, breakfast });
        };

        const attachEvents = () => {
          elements.form.addEventListener('input', () => {
            recalculate();
            saveValues();
            updateLocationHeadlamp();
          });
          elements.first.addEventListener('change', () => {
            recalculate();
            saveValues();
            updateLocationHeadlamp();
          });
          elements.location.addEventListener('change', () => {
            // Always sync travel with location changes
            syncTravelWithLocation();
            recalculate();
            saveValues();
            updateLocationHeadlamp();
          });

          elements.form.addEventListener('submit', (event) => event.preventDefault());
        };

        // Ensure DOM is ready
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            loadValues();
            attachEvents();
            recalculate();
            initAwareness();
            updateLocationHeadlamp();
          });
        } else {
          loadValues();
          attachEvents();
          recalculate();
          initAwareness();
          updateLocationHeadlamp();
        }

        // Expose for testing
        window.currentDawnDate = currentDawnDate;
        window.updateLocationHeadlamp = updateLocationHeadlamp;
        window.setTestDawn = (hours, minutes) => {
          const date = new Date();
          date.setHours(hours, minutes, 0, 0);
          currentDawnDate = date;
          window.currentDawnDate = date;
          updateLocationHeadlamp();
        };
      })();
    </script>
  </body>
</html>
